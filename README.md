# Сервис по работе с ПВЗ
Репозиторий содержит решение тестового задания для Авито.
Сервис позволяет сотрудникам ПВЗ, вносить информацию по заказам в рамках приёмки товаров.

> [Спецификация сервиса](./_specs/swagger.yaml)<br>
> [Описание задания](./_specs/Backend-trainee-assignment-spring-2025.md)

## Инструкции для запуска
Сервис можно собрать и запустить при помощи `docker compose`.
1. Для корректной работы сервиса нужно в директории `./config` разместить файл `app.env`.
Пример содержимого файла `./config/app.env`:
    ```ini
    POSTGRES_HOST=db
    POSTGRES_PORT=5432
    POSTGRES_USER=username
    POSTGRES_PASSWORD=password
    POSTGRES_DB=dbname
    DB_SSLMODE=disable
    APP_HOST=localhost
    APP_PORT=8080
    APP_SECRET=your_jwt_hs256_secret
    ``` 
2. В корне проекта выполнить `docker compose up -d --build`


## Devlog

### Кодогенерация
В качестве кодогенератора для эндпойнтов был выбран инструмент `openapi-generator-cli`.
Кодогенерацию можно осуществить с помощью `make` (цели `dto_generate`, `dto_regenerate`, `dto_clean`)
Часть параметров кодогенерации вынесена в файл `./_specs/openapi_generator_config.yaml`

### Роли
1. Примем, что упоминаемые в ТЗ названия ролей соотносятся следующим образом:
- **"модератор"** == **"moderator"**
- **"сотрудник ПВЗ"** == **"client"**
2. Сейчас в сервисе только 2 роли: *клиент* и *модератор*. У ролей нет никаких метаданных, и судя по схеме, каждый пользователь может иметь только одну роль. По мере развития сервиса может появиться потребность расширить понятие "роли", добавив метаданные (например, права доступа). Поэтому на всякий случай заранее создадим таблицу с ролями в БД.
3. Чтобы не переусложнять проект таблица `roles` из БД пока не используется. Проверка ролей и разграничение доступа реализованы в `./security/auth.go`

### Эндпойнт GET /pvz
1. Задание подразумевает что мы выводим информацию о ПВЗ. Однако опрос БД в порядке: `PVZ -> Receptions -> Products` выглядит малопроизводительным. Более логичным подходом кажется пойти в обратном порядке `Products -> Receptions -> PVZ`, попутно группируя данные. Альтернативный  подход: JOIN всех таблиц на стороне БД. 
    - **Минусы подхода:** много дублирующихся данных, которые передаются по сети, больше процессорного времени на стороне БД. 
    - **Плюсы:** меньше процессорного времени на сборку ответа.
